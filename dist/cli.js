"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readConfig = void 0;
const move_to_ts_1 = require("@manahippo/move-to-ts");
const aptos_1 = require("aptos");
const commander_1 = require("commander");
const fs = __importStar(require("fs"));
const yaml = __importStar(require("yaml"));
const Nexus = __importStar(require("./nexus"));
const readConfig = (program) => {
    const { config, profile } = program.opts();
    const ymlContent = fs.readFileSync(config, { encoding: "utf-8" });
    const result = yaml.parse(ymlContent);
    //console.log(result);
    if (!result.profiles) {
        throw new Error("Expect a profiles to be present in yaml config");
    }
    if (!result.profiles[profile]) {
        throw new Error(`Expect a ${profile} profile to be present in yaml config`);
    }
    const url = result.profiles[profile].rest_url;
    const privateKeyStr = result.profiles[profile].private_key;
    if (!url) {
        throw new Error(`Expect rest_url to be present in ${profile} profile`);
    }
    if (!privateKeyStr) {
        throw new Error(`Expect private_key to be present in ${profile} profile`);
    }
    const privateKey = new aptos_1.HexString(privateKeyStr);
    const client = new aptos_1.AptosClient(result.profiles[profile].rest_url);
    const account = new aptos_1.AptosAccount(privateKey.toUint8Array());
    console.log(`Using address ${account.address().hex()}`);
    return { client, account };
};
exports.readConfig = readConfig;
const program = new commander_1.Command();
program
    .name('yarn cli')
    .description('Move TS CLI generated by move-to-ts')
    .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
    .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default');
const assets_init_all_coin_types = () => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const payload = Nexus.Assets.buildPayload_init_all_coin_types();
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("assets:init-all-coin-types")
    .description("")
    .action(assets_init_all_coin_types);
const assets_init_coin_types = () => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const payload = Nexus.Assets.buildPayload_init_coin_types();
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("assets:init-coin-types")
    .description("")
    .action(assets_init_coin_types);
const assets_mint = (CoinType, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const CoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(CoinType);
    const amount_ = (0, move_to_ts_1.u64)(amount);
    const payload = Nexus.Assets.buildPayload_mint(amount_, [CoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("assets:mint")
    .description("")
    .argument('<TYPE_CoinType>')
    .argument('<amount>')
    .action(assets_mint);
const assets_mint_and_deposit = (CoinType, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const CoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(CoinType);
    const amount_ = (0, move_to_ts_1.u64)(amount);
    const payload = Nexus.Assets.buildPayload_mint_and_deposit(amount_, [CoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("assets:mint-and-deposit")
    .description("")
    .argument('<TYPE_CoinType>')
    .argument('<amount>')
    .action(assets_mint_and_deposit);
const market_cancel_all_limit_orders_user = (host, market_id, side) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const host_ = new aptos_1.HexString(host);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const side_ = side == 'true';
    const payload = Nexus.Market.buildPayload_cancel_all_limit_orders_user(host_, market_id_, side_);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:cancel-all-limit-orders-user")
    .description("")
    .argument('<host>')
    .argument('<market_id>')
    .argument('<side>')
    .action(market_cancel_all_limit_orders_user);
const market_cancel_limit_order_user = (host, market_id, side, order_id) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const host_ = new aptos_1.HexString(host);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const side_ = side == 'true';
    const order_id_ = (0, move_to_ts_1.u128)(order_id);
    const payload = Nexus.Market.buildPayload_cancel_limit_order_user(host_, market_id_, side_, order_id_);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:cancel-limit-order-user")
    .description("")
    .argument('<host>')
    .argument('<market_id>')
    .argument('<side>')
    .argument('<order_id>')
    .action(market_cancel_limit_order_user);
const market_place_limit_order_user = (BaseType, QuoteType, host, market_id, side, size, price, post_or_abort, fill_or_abort, immediate_or_cancel) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseType);
    const QuoteType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteType);
    const host_ = new aptos_1.HexString(host);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const side_ = side == 'true';
    const size_ = (0, move_to_ts_1.u64)(size);
    const price_ = (0, move_to_ts_1.u64)(price);
    const post_or_abort_ = post_or_abort == 'true';
    const fill_or_abort_ = fill_or_abort == 'true';
    const immediate_or_cancel_ = immediate_or_cancel == 'true';
    const payload = Nexus.Market.buildPayload_place_limit_order_user(host_, market_id_, side_, size_, price_, post_or_abort_, fill_or_abort_, immediate_or_cancel_, [BaseType_, QuoteType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:place-limit-order-user")
    .description("")
    .argument('<TYPE_BaseType>')
    .argument('<TYPE_QuoteType>')
    .argument('<host>')
    .argument('<market_id>')
    .argument('<side>')
    .argument('<size>')
    .argument('<price>')
    .argument('<post_or_abort>')
    .argument('<fill_or_abort>')
    .argument('<immediate_or_cancel>')
    .action(market_place_limit_order_user);
const market_place_market_order_user = (BaseType, QuoteType, host, market_id, direction, min_base, max_base, min_quote, max_quote, limit_price) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseType);
    const QuoteType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteType);
    const host_ = new aptos_1.HexString(host);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const direction_ = direction == 'true';
    const min_base_ = (0, move_to_ts_1.u64)(min_base);
    const max_base_ = (0, move_to_ts_1.u64)(max_base);
    const min_quote_ = (0, move_to_ts_1.u64)(min_quote);
    const max_quote_ = (0, move_to_ts_1.u64)(max_quote);
    const limit_price_ = (0, move_to_ts_1.u64)(limit_price);
    const payload = Nexus.Market.buildPayload_place_market_order_user(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseType_, QuoteType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:place-market-order-user")
    .description("")
    .argument('<TYPE_BaseType>')
    .argument('<TYPE_QuoteType>')
    .argument('<host>')
    .argument('<market_id>')
    .argument('<direction>')
    .argument('<min_base>')
    .argument('<max_base>')
    .argument('<min_quote>')
    .argument('<max_quote>')
    .argument('<limit_price>')
    .action(market_place_market_order_user);
const market_register_market_generic = (BaseType, QuoteType, lot_size, tick_size, generic_asset_transfer_custodian_id) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseType);
    const QuoteType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteType);
    const lot_size_ = (0, move_to_ts_1.u64)(lot_size);
    const tick_size_ = (0, move_to_ts_1.u64)(tick_size);
    const generic_asset_transfer_custodian_id_ = (0, move_to_ts_1.u64)(generic_asset_transfer_custodian_id);
    const payload = Nexus.Market.buildPayload_register_market_generic(lot_size_, tick_size_, generic_asset_transfer_custodian_id_, [BaseType_, QuoteType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:register-market-generic")
    .description("")
    .argument('<TYPE_BaseType>')
    .argument('<TYPE_QuoteType>')
    .argument('<lot_size>')
    .argument('<tick_size>')
    .argument('<generic_asset_transfer_custodian_id>')
    .action(market_register_market_generic);
const market_register_market_pure_coin = (BaseCoinType, QuoteCoinType, lot_size, tick_size) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseCoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseCoinType);
    const QuoteCoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteCoinType);
    const lot_size_ = (0, move_to_ts_1.u64)(lot_size);
    const tick_size_ = (0, move_to_ts_1.u64)(tick_size);
    const payload = Nexus.Market.buildPayload_register_market_pure_coin(lot_size_, tick_size_, [BaseCoinType_, QuoteCoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:register-market-pure-coin")
    .description("")
    .argument('<TYPE_BaseCoinType>')
    .argument('<TYPE_QuoteCoinType>')
    .argument('<lot_size>')
    .argument('<tick_size>')
    .action(market_register_market_pure_coin);
const market_swap_between_coinstores = (BaseCoinType, QuoteCoinType, host, market_id, direction, min_base, max_base, min_quote, max_quote, limit_price) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseCoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseCoinType);
    const QuoteCoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteCoinType);
    const host_ = new aptos_1.HexString(host);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const direction_ = direction == 'true';
    const min_base_ = (0, move_to_ts_1.u64)(min_base);
    const max_base_ = (0, move_to_ts_1.u64)(max_base);
    const min_quote_ = (0, move_to_ts_1.u64)(min_quote);
    const max_quote_ = (0, move_to_ts_1.u64)(max_quote);
    const limit_price_ = (0, move_to_ts_1.u64)(limit_price);
    const payload = Nexus.Market.buildPayload_swap_between_coinstores(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseCoinType_, QuoteCoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("market:swap-between-coinstores")
    .description("")
    .argument('<TYPE_BaseCoinType>')
    .argument('<TYPE_QuoteCoinType>')
    .argument('<host>')
    .argument('<market_id>')
    .argument('<direction>')
    .argument('<min_base>')
    .argument('<max_base>')
    .argument('<min_quote>')
    .argument('<max_quote>')
    .argument('<limit_price>')
    .action(market_swap_between_coinstores);
const registry_init_registry = () => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const payload = Nexus.Registry.buildPayload_init_registry();
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("registry:init-registry")
    .description("")
    .action(registry_init_registry);
const user_deposit_from_coinstore = (CoinType, market_id, general_custodian_id, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const CoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(CoinType);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const general_custodian_id_ = (0, move_to_ts_1.u64)(general_custodian_id);
    const amount_ = (0, move_to_ts_1.u64)(amount);
    const payload = Nexus.User.buildPayload_deposit_from_coinstore(market_id_, general_custodian_id_, amount_, [CoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("user:deposit-from-coinstore")
    .description("")
    .argument('<TYPE_CoinType>')
    .argument('<market_id>')
    .argument('<general_custodian_id>')
    .argument('<amount>')
    .action(user_deposit_from_coinstore);
const user_register_market_account = (BaseType, QuoteType, market_id, general_custodian_id) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const BaseType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(BaseType);
    const QuoteType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(QuoteType);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const general_custodian_id_ = (0, move_to_ts_1.u64)(general_custodian_id);
    const payload = Nexus.User.buildPayload_register_market_account(market_id_, general_custodian_id_, [BaseType_, QuoteType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("user:register-market-account")
    .description("")
    .argument('<TYPE_BaseType>')
    .argument('<TYPE_QuoteType>')
    .argument('<market_id>')
    .argument('<general_custodian_id>')
    .action(user_register_market_account);
const user_withdraw_to_coinstore = (CoinType, market_id, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const { client, account } = (0, exports.readConfig)(program);
    const CoinType_ = (0, move_to_ts_1.parseTypeTagOrThrow)(CoinType);
    const market_id_ = (0, move_to_ts_1.u64)(market_id);
    const amount_ = (0, move_to_ts_1.u64)(amount);
    const payload = Nexus.User.buildPayload_withdraw_to_coinstore(market_id_, amount_, [CoinType_]);
    yield (0, move_to_ts_1.sendPayloadTx)(client, account, payload);
});
program
    .command("user:withdraw-to-coinstore")
    .description("")
    .argument('<TYPE_CoinType>')
    .argument('<market_id>')
    .argument('<amount>')
    .action(user_withdraw_to_coinstore);
program.parse();
//# sourceMappingURL=cli.js.map