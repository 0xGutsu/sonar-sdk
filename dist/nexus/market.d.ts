import * as $ from "@manahippo/move-to-ts";
import { AptosDataCache, AptosParserRepo, AptosLocalCache } from "@manahippo/move-to-ts";
import { U64, U128 } from "@manahippo/move-to-ts";
import { TypeParamDeclType, FieldDeclType } from "@manahippo/move-to-ts";
import { StructTag, TypeTag } from "@manahippo/move-to-ts";
import { HexString, AptosClient, AptosAccount, TxnBuilderTypes, Types } from "aptos";
import * as Stdlib from "../stdlib";
import * as Critbit from "./critbit";
import * as Open_table from "./open_table";
import * as Registry from "./registry";
export declare const packageName = "Nexus";
export declare const moduleAddress: HexString;
export declare const moduleName = "market";
export declare const ASK: boolean;
export declare const BID: boolean;
export declare const BUY: boolean;
export declare const E_BOTH_COINS: U64;
export declare const E_INBOUND_ASSET_OVERFLOW: U64;
export declare const E_INVALID_BASE: U64;
export declare const E_INVALID_CUSTODIAN: U64;
export declare const E_INVALID_OPTION_BASE: U64;
export declare const E_INVALID_OPTION_QUOTE: U64;
export declare const E_INVALID_QUOTE: U64;
export declare const E_INVALID_USER: U64;
export declare const E_LIMIT_PRICE_0: U64;
export declare const E_MIN_BASE_EXCEEDS_MAX: U64;
export declare const E_MIN_LOTS_NOT_FILLED: U64;
export declare const E_MIN_QUOTE_EXCEEDS_MAX: U64;
export declare const E_MIN_TICKS_NOT_FILLED: U64;
export declare const E_NOT_ENOUGH_OUTBOUND_ASSET: U64;
export declare const E_NO_ORDER: U64;
export declare const E_NO_ORDER_BOOK: U64;
export declare const E_NO_ORDER_BOOKS: U64;
export declare const E_ORDER_BOOK_EXISTS: U64;
export declare const E_POST_OR_ABORT_CROSSED_SPREAD: U64;
export declare const E_SIZE_BASE_OVERFLOW: U64;
export declare const E_SIZE_QUOTE_OVERFLOW: U64;
export declare const E_SIZE_TICKS_OVERFLOW: U64;
export declare const E_TOO_MANY_ORDER_FLAGS: U64;
export declare const HI_64: U64;
export declare const LEFT: boolean;
export declare const MAX_BID_DEFAULT: U128;
export declare const MIN_ASK_DEFAULT: U128;
export declare const NO_CUSTODIAN: U64;
export declare const PURE_COIN_PAIR: U64;
export declare const RIGHT: boolean;
export declare const SELL: boolean;
export declare class Order {
    typeTag: TypeTag;
    static moduleAddress: HexString;
    static moduleName: string;
    __app: $.AppType | null;
    static structName: string;
    static typeParameters: TypeParamDeclType[];
    static fields: FieldDeclType[];
    size: U64;
    user: HexString;
    general_custodian_id: U64;
    constructor(proto: any, typeTag: TypeTag);
    static OrderParser(data: any, typeTag: TypeTag, repo: AptosParserRepo): Order;
    static getTag(): StructTag;
    loadFullState(app: $.AppType): Promise<void>;
}
export declare class OrderBook {
    typeTag: TypeTag;
    static moduleAddress: HexString;
    static moduleName: string;
    __app: $.AppType | null;
    static structName: string;
    static typeParameters: TypeParamDeclType[];
    static fields: FieldDeclType[];
    base_type_info: Stdlib.Type_info.TypeInfo;
    quote_type_info: Stdlib.Type_info.TypeInfo;
    lot_size: U64;
    tick_size: U64;
    generic_asset_transfer_custodian_id: U64;
    asks: Critbit.CritBitTree;
    bids: Critbit.CritBitTree;
    min_ask: U128;
    max_bid: U128;
    counter: U64;
    constructor(proto: any, typeTag: TypeTag);
    static OrderBookParser(data: any, typeTag: TypeTag, repo: AptosParserRepo): OrderBook;
    static getTag(): StructTag;
    loadFullState(app: $.AppType): Promise<void>;
}
export declare class OrderBooks {
    typeTag: TypeTag;
    static moduleAddress: HexString;
    static moduleName: string;
    __app: $.AppType | null;
    static structName: string;
    static typeParameters: TypeParamDeclType[];
    static fields: FieldDeclType[];
    map: Open_table.OpenTable;
    constructor(proto: any, typeTag: TypeTag);
    static OrderBooksParser(data: any, typeTag: TypeTag, repo: AptosParserRepo): OrderBooks;
    static load(repo: AptosParserRepo, client: AptosClient, address: HexString, typeParams: TypeTag[]): Promise<OrderBooks>;
    static loadByApp(app: $.AppType, address: HexString, typeParams: TypeTag[]): Promise<OrderBooks>;
    static getTag(): StructTag;
    loadFullState(app: $.AppType): Promise<void>;
}
export declare function cancel_all_limit_orders_(user: HexString, host: HexString, market_id: U64, general_custodian_id: U64, side: boolean, $c: AptosDataCache): void;
export declare function cancel_all_limit_orders_custodian_(user: HexString, host: HexString, market_id: U64, side: boolean, general_custodian_capability_ref: Registry.CustodianCapability, $c: AptosDataCache): void;
export declare function cancel_all_limit_orders_user_(user: HexString, host: HexString, market_id: U64, side: boolean, $c: AptosDataCache): void;
export declare function buildPayload_cancel_all_limit_orders_user(host: HexString, market_id: U64, side: boolean, isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function cancel_limit_order_(user: HexString, host: HexString, market_id: U64, general_custodian_id: U64, side: boolean, order_id: U128, $c: AptosDataCache): void;
export declare function cancel_limit_order_custodian_(user: HexString, host: HexString, market_id: U64, side: boolean, order_id: U128, general_custodian_capability_ref: Registry.CustodianCapability, $c: AptosDataCache): void;
export declare function cancel_limit_order_user_(user: HexString, host: HexString, market_id: U64, side: boolean, order_id: U128, $c: AptosDataCache): void;
export declare function buildPayload_cancel_limit_order_user(host: HexString, market_id: U64, side: boolean, order_id: U128, isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function get_counter_(order_book_ref_mut: OrderBook, $c: AptosDataCache): U64;
export declare function match_(market_id_ref: U64, order_book_ref_mut: OrderBook, lot_size_ref: U64, tick_size_ref: U64, direction_ref: boolean, min_lots_ref: U64, max_lots_ref: U64, min_ticks_ref: U64, max_ticks_ref: U64, limit_price_ref: U64, optional_base_coins_ref_mut: Stdlib.Option.Option, optional_quote_coins_ref_mut: Stdlib.Option.Option, lots_filled_ref_mut: U64, ticks_filled_ref_mut: U64, $c: AptosDataCache, $p: TypeTag[]): U128[];
export declare function match_from_market_account_(user_ref: HexString, market_account_id_ref: U128, market_id_ref: U64, order_book_ref_mut: OrderBook, direction_ref: boolean, min_base_ref: U64, max_base_ref: U64, min_quote_ref: U64, max_quote_ref: U64, limit_price_ref: U64, lots_filled_ref_mut: U64, target_order_ids_ref_mut: U128[], $c: AptosDataCache, $p: TypeTag[]): [U64, U64];
export declare function match_init_(order_book_ref_mut: OrderBook, direction_ref: boolean, max_lots_ref: U64, max_ticks_ref: U64, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, boolean, Critbit.CritBitTree, U128, U64, boolean];
export declare function match_loop_(market_id_ref: U64, tree_ref_mut: Critbit.CritBitTree, side_ref: boolean, lot_size_ref: U64, tick_size_ref: U64, lots_until_max_ref_mut: U64, ticks_until_max_ref_mut: U64, limit_price_ref: U64, n_orders_ref_mut: U64, spread_maker_ref_mut: U128, traversal_direction_ref: boolean, optional_base_coins_ref_mut: Stdlib.Option.Option, optional_quote_coins_ref_mut: Stdlib.Option.Option, $c: AptosDataCache, $p: TypeTag[]): U128[];
export declare function match_loop_break_(spread_maker_ref_mut: U128, new_spread_maker_ref: U128, should_pop_last_ref: boolean, tree_ref_mut: Critbit.CritBitTree, final_order_id_ref: U128, $c: AptosDataCache): void;
export declare function match_loop_init_(tree_ref_mut: Critbit.CritBitTree, traversal_direction_ref: boolean, $c: AptosDataCache): [U128, Order, U64, U64, boolean, boolean, U128];
export declare function match_loop_order_(market_id_ref: U64, side_ref: boolean, lot_size_ref: U64, tick_size_ref: U64, lots_until_max_ref_mut: U64, ticks_until_max_ref_mut: U64, limit_price_ref: U64, target_order_id_ref: U128, target_order_ref_mut: Order, complete_target_fill_ref_mut: boolean, optional_base_coins_ref_mut: Stdlib.Option.Option, optional_quote_coins_ref_mut: Stdlib.Option.Option, $c: AptosDataCache, $p: TypeTag[]): void;
export declare function match_loop_order_fill_size_(lots_until_max_ref: U64, ticks_until_max_ref: U64, target_order_price_ref: U64, target_order_ref: Order, fill_size_ref_mut: U64, complete_target_fill_ref_mut: boolean, $c: AptosDataCache): void;
export declare function match_loop_order_follow_up_(tree_ref_mut: Critbit.CritBitTree, side_ref: boolean, traversal_direction_ref: boolean, n_orders_ref_mut: U64, complete_target_fill_ref: boolean, should_pop_last_ref_mut: boolean, target_order_id: U128, target_parent_index_ref_mut: U64, target_child_index_ref_mut: U64, new_spread_maker_ref_mut: U128, $c: AptosDataCache): [U128, Order, boolean];
export declare function match_range_check_fills_(direction_ref: boolean, min_base_ref: U64, max_base_ref: U64, min_quote_ref: U64, max_quote_ref: U64, base_available_ref: U64, base_ceiling_ref: U64, quote_available_ref: U64, quote_ceiling_ref: U64, $c: AptosDataCache): void;
export declare function match_verify_fills_(min_lots_ref: U64, max_lots_ref: U64, min_ticks_ref: U64, max_ticks_ref: U64, lots_until_max_ref: U64, ticks_until_max_ref: U64, lots_filled_ref_mut: U64, ticks_filled_ref_mut: U64, $c: AptosDataCache): void;
export declare function place_limit_order_(user_ref: HexString, host_ref: HexString, market_id_ref: U64, general_custodian_id_ref: U64, side_ref: boolean, size_ref: U64, price_ref: U64, post_or_abort_ref: boolean, fill_or_abort_ref: boolean, immediate_or_cancel_ref: boolean, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128, U128[]];
export declare function place_limit_order_custodian_(user: HexString, host: HexString, market_id: U64, side: boolean, size: U64, price: U64, post_or_abort: boolean, fill_or_abort: boolean, immediate_or_cancel: boolean, general_custodian_capability_ref: Registry.CustodianCapability, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128, U128[]];
export declare function place_limit_order_post_match_(user_ref: HexString, order_book_ref_mut: OrderBook, market_account_id_ref: U128, general_custodian_id_ref: U64, lot_size_ref: U64, tick_size_ref: U64, side_ref: boolean, size_ref: U64, price_ref: U64, lots_filled_ref: U64, immediate_or_cancel_ref: boolean, $c: AptosDataCache): U128;
export declare function place_limit_order_pre_match_(user_ref: HexString, order_book_ref: OrderBook, market_id_ref: U64, general_custodian_id_ref: U64, side_ref: boolean, size_ref: U64, price_ref: U64, post_or_abort_ref: boolean, fill_or_abort_ref: boolean, immediate_or_cancel_ref: boolean, market_account_id_ref_mut: U128, lot_size_ref_mut: U64, tick_size_ref_mut: U64, direction_ref_mut: boolean, min_base_ref_mut: U64, max_base_ref_mut: U64, max_quote_ref_mut: U64, $c: AptosDataCache): void;
export declare function place_limit_order_user_(user: HexString, host: HexString, market_id: U64, side: boolean, size: U64, price: U64, post_or_abort: boolean, fill_or_abort: boolean, immediate_or_cancel: boolean, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128, U128[]];
export declare function buildPayload_place_limit_order_user(host: HexString, market_id: U64, side: boolean, size: U64, price: U64, post_or_abort: boolean, fill_or_abort: boolean, immediate_or_cancel: boolean, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function place_market_order_(user_ref: HexString, host_ref: HexString, market_id_ref: U64, general_custodian_id_ref: U64, direction_ref: boolean, min_base_ref: U64, max_base_ref: U64, min_quote_ref: U64, max_quote_ref: U64, limit_price_ref: U64, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128[]];
export declare function place_market_order_custodian_(user: HexString, host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, general_custodian_capability_ref: Registry.CustodianCapability, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128[]];
export declare function place_market_order_user_(user: HexString, host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128[]];
export declare function buildPayload_place_market_order_user(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function register_market_(host: HexString, lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $c: AptosDataCache, $p: TypeTag[]): U64;
export declare function register_market_generic_(host: HexString, lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $c: AptosDataCache, $p: TypeTag[]): void;
export declare function buildPayload_register_market_generic(lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function register_market_pure_coin_(host: HexString, lot_size: U64, tick_size: U64, $c: AptosDataCache, $p: TypeTag[]): void;
export declare function buildPayload_register_market_pure_coin(lot_size: U64, tick_size: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function register_order_book_(host: HexString, market_id: U64, lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $c: AptosDataCache, $p: TypeTag[]): void;
export declare function swap_(host_ref: HexString, market_id_ref: U64, direction_ref: boolean, min_base_ref: U64, max_base_ref: U64, min_quote_ref: U64, max_quote_ref: U64, limit_price_ref: U64, optional_base_coins_ref_mut: Stdlib.Option.Option, optional_quote_coins_ref_mut: Stdlib.Option.Option, base_filled_ref_mut: U64, quote_filled_ref_mut: U64, generic_asset_transfer_custodian_id_ref: U64, target_order_ids_ref_mut: U128[], $c: AptosDataCache, $p: TypeTag[]): void;
export declare function swap_between_coinstores_(user: HexString, host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $c: AptosDataCache, $p: TypeTag[]): U128[];
export declare function buildPayload_swap_between_coinstores(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
export declare function swap_coins_(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, base_coins_ref_mut: Stdlib.Coin.Coin, quote_coins_ref_mut: Stdlib.Coin.Coin, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128[]];
export declare function swap_generic_(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, optional_base_coins_ref_mut: Stdlib.Option.Option, optional_quote_coins_ref_mut: Stdlib.Option.Option, generic_asset_transfer_custodian_capability_ref: Registry.CustodianCapability, $c: AptosDataCache, $p: TypeTag[]): [U64, U64, U128[]];
export declare function verify_order_book_exists_(host: HexString, market_id: U64, $c: AptosDataCache): void;
export declare function loadParsers(repo: AptosParserRepo): void;
export declare class App {
    client: AptosClient;
    repo: AptosParserRepo;
    cache: AptosLocalCache;
    constructor(client: AptosClient, repo: AptosParserRepo, cache: AptosLocalCache);
    get moduleAddress(): HexString;
    get moduleName(): string;
    get Order(): typeof Order;
    get OrderBook(): typeof OrderBook;
    get OrderBooks(): typeof OrderBooks;
    loadOrderBooks(owner: HexString, loadFull?: boolean): Promise<OrderBooks>;
    payload_cancel_all_limit_orders_user(host: HexString, market_id: U64, side: boolean, isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    cancel_all_limit_orders_user(_account: AptosAccount, host: HexString, market_id: U64, side: boolean, _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_cancel_limit_order_user(host: HexString, market_id: U64, side: boolean, order_id: U128, isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    cancel_limit_order_user(_account: AptosAccount, host: HexString, market_id: U64, side: boolean, order_id: U128, _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_place_limit_order_user(host: HexString, market_id: U64, side: boolean, size: U64, price: U64, post_or_abort: boolean, fill_or_abort: boolean, immediate_or_cancel: boolean, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    place_limit_order_user(_account: AptosAccount, host: HexString, market_id: U64, side: boolean, size: U64, price: U64, post_or_abort: boolean, fill_or_abort: boolean, immediate_or_cancel: boolean, $p: TypeTag[], /* <BaseType, QuoteType>*/ _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_place_market_order_user(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    place_market_order_user(_account: AptosAccount, host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_register_market_generic(lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    register_market_generic(_account: AptosAccount, lot_size: U64, tick_size: U64, generic_asset_transfer_custodian_id: U64, $p: TypeTag[], /* <BaseType, QuoteType>*/ _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_register_market_pure_coin(lot_size: U64, tick_size: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    register_market_pure_coin(_account: AptosAccount, lot_size: U64, tick_size: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
    payload_swap_between_coinstores(host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ isJSON?: boolean): TxnBuilderTypes.TransactionPayloadEntryFunction | Types.TransactionPayload_EntryFunctionPayload;
    swap_between_coinstores(_account: AptosAccount, host: HexString, market_id: U64, direction: boolean, min_base: U64, max_base: U64, min_quote: U64, max_quote: U64, limit_price: U64, $p: TypeTag[], /* <BaseCoinType, QuoteCoinType>*/ _maxGas?: number, _isJSON?: boolean): Promise<Types.UserTransaction>;
}
//# sourceMappingURL=market.d.ts.map